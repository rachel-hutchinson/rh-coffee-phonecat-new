# STEP 5

Enough of building an app with three phones in a hard-coded dataset! Let's fetch a larger dataset from our server using one of Angular's built-in services called `$http`. We will use Angular's dependency injection (DI) to provide the service to the `PhoneListCtrl` controller.

There is now a list of 20 phones, loaded from the server.

The most important changes are listed below.

### Data
The `app/phones/phones.json` file in your project is a dataset that contains a larger list of phones stored in the JSON format.

Following is a sample of the file:
```
[
	{
		 "age": 13,
		 "id": "motorola-defy-with-motoblur",
		 "name": "Motorola DEFY\u2122 with MOTOBLUR\u2122",
		 "snippet": "Are you ready for everything life throws your way?"
		 ...
	},
...
]
```

### Controller
We'll use Angular's `$http` service in our controller to make an HTTP request to your web server to fetch the data in the `app/phones/phones.json` file. `$http` is just one of several built-in Angular services that handle common operations in web apps. Angular injects these services for you where you need them.

Services are managed by Angular's DI subsystem. Dependency injection helps to make your web apps both well-structured (e.g., separate components for presentation, data, and control) and loosely coupled (dependencies between components are not resolved by the components themselves, but by the DI subsystem).

**app/js/controllers.js.coffee:**
```
phonecatApp = angular.module('phonecatApp', [])

phonecatApp.controller 'PhoneListCtrl', ($scope, $http) ->
  $http.get('phones/phones.json')
  .then (httpresponse) ->
    $scope.phones = httpresponse.data

  $scope.orderProp = 'age'
```
`$http` makes an HTTP GET request to our web server, asking for `phones/phones.json` (the url is relative to our `index.html` file inside `release`). The server responds by providing the data in the json file. (The response might just as well have been dynamically generated by a backend server. To the browser and our app they both look the same. For the sake of simplicity we used a json file in this tutorial.)

The `$http` service returns a promise object with a success method. We call this method to handle the asynchronous response and assign the phone data to the scope controlled by this controller, as a model called phones. Notice that Angular detected the json response and parsed it for us!

To use a service in Angular, you simply declare the names of the dependencies you need as arguments to the controller's constructor function, as follows:
```
phonecatApp.controller 'PhoneListCtrl', ($scope, $http) ->
```
Angular's dependency injector provides services to your controller when the controller is being constructed. The dependency injector also takes care of creating any transitive dependencies the service may have (services often depend upon other services).

Note that the names of arguments are significant, because the injector uses these to look up the dependencies.

### `$` Prefix Naming Convention
You can create your own services, and in fact we will do exactly that in step 11. As a naming convention, Angular's built-in services, Scope methods and a few other Angular APIs have a `$` prefix in front of the name.

The `$` prefix is there to namespace Angular-provided services. To prevent collisions it's best to avoid naming your services and models anything that begins with a `$`.

If you inspect a Scope, you may also notice some properties that begin with `$$`. These properties are considered private, and should not be accessed or modified.

### A Note on Promises
A Promise in short:

*"Imagine you are a kid. Your mom **promises** you that she'll get you a new phone next week."*

You *don't know* if you will get that phone until next week. Your mom can either *really buy* you a brand new phone, or *stand you up* and withhold the phone if she is not happy :(.

That is a **promise**. A promise has 3 states. They are:

- Promise is **pending**: You don't know if you will get that phone until next week.
- Promise is **resolved**: Your mom really buy you a brand new phone.
- Promise is **rejected**: You don't get a new phone because your mom is not happy.

These are implemented in JavaScript to solve the problem of weird callbacks and infinitely passing around functions to call when other functions have completed. These are also available in CoffeeScript and **should always** be used over callbacks.

In this step you can think of `$http` as the *promise* of receiving *some* data. You don't know what the data will be, you might have an idea of what it *could* look like, but you could also be wrong and should account for this.

A full example of handling this from the `$http` call given here is:
```
  $http.get('phones/phones.json')
  .then (httpresponse) ->
    $scope.phones = httpresponse.data
  , (rejected) ->
    # the call failed ):
    # do something with the error
```

These can also be chained:
```
  $http.get('phones/phones.json')
  .then (httpresponse) ->
    $scope.phones = httpresponse.data
    # return the promise object for the next step in the chain to act on
    $http.get('phones/phones.json')
  .then (new_httpresponse) ->
    # print out of the same data
    console.log new_httpresponse
  , (rejected) ->
    # the call failed ):
    # do something with the error
```

Referrence material only:
https://gist.github.com/pketh/2d036345483b690d5da020f2903891d7
https://stackoverflow.com/questions/17510756/chaining-promises-in-coffeescript
https://www.promisejs.org/patterns/

### Experiments
At the bottom of `index.html`, add a `<pre>{{phones | filter:query | orderBy:orderProp | json}}</pre>` binding to see the list of phones displayed in json format.

In the `PhoneListCtrl` controller, pre-process the http response by limiting the number of phones to the first 5 in the list. Use the following code in the `$http` callback:
```
$scope.phones = data.splice(0, 5)
```
## Summary
Now that you have learned how easy it is to use Angular services (thanks to Angular's dependency injection), go to step 6, where you will add some thumbnail images of phones and some links.